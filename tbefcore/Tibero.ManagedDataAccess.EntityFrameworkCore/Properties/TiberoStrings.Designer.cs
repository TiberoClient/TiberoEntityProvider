//------------------------------------------------------------------------------
// <auto-generated>
//     이 코드는 도구를 사용하여 생성되었습니다.
//     런타임 버전:4.0.30319.42000
//
//     파일 내용을 변경하면 잘못된 동작이 발생할 수 있으며, 코드를 다시 생성하면
//     이러한 변경 내용이 손실됩니다.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Tibero.EntityFrameworkCore.Properties {
    using System;
    
    
    /// <summary>
    ///   지역화된 문자열 등을 찾기 위한 강력한 형식의 리소스 클래스입니다.
    /// </summary>
    // 이 클래스는 ResGen 또는 Visual Studio와 같은 도구를 통해 StronglyTypedResourceBuilder
    // 클래스에서 자동으로 생성되었습니다.
    // 멤버를 추가하거나 제거하려면 .ResX 파일을 편집한 다음 /str 옵션을 사용하여 ResGen을
    // 다시 실행하거나 VS 프로젝트를 다시 빌드하십시오.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class TiberoStrings {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal TiberoStrings() {
        }
        
        /// <summary>
        ///   이 클래스에서 사용하는 캐시된 ResourceManager 인스턴스를 반환합니다.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Tibero.EntityFrameworkCore.Properties.TiberoStrings", typeof(TiberoStrings).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   이 강력한 형식의 리소스 클래스를 사용하여 모든 리소스 조회에 대해 현재 스레드의 CurrentUICulture 속성을
        ///   재정의합니다.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   To change the IDENTITY property of a column, the column needs to be dropped and recreated.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string AlterIdentityColumn {
            get {
                return ResourceManager.GetString("AlterIdentityColumn", resourceCulture);
            }
        }
        
        /// <summary>
        ///   To set memory-optimized on a table on or off the table needs to be dropped and recreated.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string DuplicateColumnNameValueGenerationStrategyMismatch {
            get {
                return ResourceManager.GetString("DuplicateColumnNameValueGenerationStrategyMismatch", resourceCulture);
            }
        }
        
        /// <summary>
        ///   The &apos;FreeText&apos; method is not supported because the query has switched to client-evaluation. Inspect the log to determine which query expressions are triggering client-evaluation.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string FreeTextFunctionOnClient {
            get {
                return ResourceManager.GetString("FreeTextFunctionOnClient", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Identity value generation cannot be used for the property &apos;{property}&apos; on entity type &apos;{entityType}&apos; because the property type is &apos;{propertyType}&apos;. Identity value generation can only be used with signed integer properties.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string IdentityBadType {
            get {
                return ResourceManager.GetString("IdentityBadType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   SQL Server requires the table name to be specified for rename index operations. Specify table name in the call to MigrationBuilder.RenameIndex.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string IndexTableRequired {
            get {
                return ResourceManager.GetString("IndexTableRequired", resourceCulture);
            }
        }
        
        /// <summary>
        ///   The expression passed to the &apos;propertyReference&apos; parameter of the &apos;FreeText&apos; method is not a valid reference to a property. The expression should represent a reference to a full-text indexed property on the object referenced in the from clause: &apos;from e in context.Entities where EF.Functions.FreeText(e.SomeProperty, textToSearchFor) select e&apos;과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string InvalidColumnNameForFreeText {
            get {
                return ResourceManager.GetString("InvalidColumnNameForFreeText", resourceCulture);
            }
        }
        
        /// <summary>
        ///   The specified table &apos;{table}&apos; is not valid. Specify tables using the format &apos;[schema].[table]&apos;.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string InvalidTableToIncludeInScaffolding {
            get {
                return ResourceManager.GetString("InvalidTableToIncludeInScaffolding", resourceCulture);
            }
        }
        
        /// <summary>
        ///   The property &apos;{property}&apos; on entity type &apos;{entityType}&apos; is of type &apos;byte&apos;, but is set up to use a SQL Server identity column. This requires that values starting at 255 and counting down will be used for temporary key values. A temporary key value is needed for every entity inserted in a single call to &apos;SaveChanges&apos;. Care must be taken that these values do not collide with real key values.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogByteIdentityColumn {
            get {
                return ResourceManager.GetString("LogByteIdentityColumn", resourceCulture);
            }
        }
        
        /// <summary>
        ///   No type was specified for the decimal column &apos;{property}&apos; on entity type &apos;{entityType}&apos;. This will cause values to be silently truncated if they do not fit in the default precision and scale. Explicitly specify the SQL server column type that can accommodate all the values using &apos;ForHasColumnType()&apos;.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogDefaultDecimalTypeColumn {
            get {
                return ResourceManager.GetString("LogDefaultDecimalTypeColumn", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Found column with table: {tableName}, column name: {columnName}, ordinal: {ordinal}, data type: {dataType}, maximum length: {maxLength}, precision: {precision}, scale: {scale}, nullable: {isNullable}, identity: {isIdentity}, default value: {defaultValue}, computed value: {computedValue}과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogFoundColumn {
            get {
                return ResourceManager.GetString("LogFoundColumn", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Found default schema {defaultSchema}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogFoundDefaultSchema {
            get {
                return ResourceManager.GetString("LogFoundDefaultSchema", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Found foreign key on table: {tableName}, name: {foreignKeyName}, principal table: {principalTableName}, delete action: {deleteAction}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogFoundForeignKey {
            get {
                return ResourceManager.GetString("LogFoundForeignKey", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Found index with name: {indexName}, table: {tableName}, is unique: {isUnique}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogFoundIndex {
            get {
                return ResourceManager.GetString("LogFoundIndex", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Found primary key with name: {primaryKeyName}, table: {tableName}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogFoundPrimaryKey {
            get {
                return ResourceManager.GetString("LogFoundPrimaryKey", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Found sequence name: {name}, data type: {dataType}, cyclic: {isCyclic}, increment: {increment}, start: {start}, minimum: {min}, maximum: {max}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogFoundSequence {
            get {
                return ResourceManager.GetString("LogFoundSequence", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Found table with name: {name}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogFoundTable {
            get {
                return ResourceManager.GetString("LogFoundTable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Found type alias with name: {alias} which maps to underlying data type {dataType}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogFoundTypeAlias {
            get {
                return ResourceManager.GetString("LogFoundTypeAlias", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Found unique constraint with name: {uniqueConstraintName}, table: {tableName}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogFoundUniqueConstraint {
            get {
                return ResourceManager.GetString("LogFoundUniqueConstraint", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Unable to find a schema in the database matching the selected schema {schema}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogMissingSchema {
            get {
                return ResourceManager.GetString("LogMissingSchema", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Unable to find a table in the database matching the selected table {table}.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogMissingTable {
            get {
                return ResourceManager.GetString("LogMissingTable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   For foreign key {foreignKeyName} on table {tableName}, unable to find the column called {principalColumnName} on the foreign key&apos;s principal table, {principaltableName}. Skipping foreign key.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogPrincipalColumnNotFound {
            get {
                return ResourceManager.GetString("LogPrincipalColumnNotFound", resourceCulture);
            }
        }
        
        /// <summary>
        ///   For foreign key {fkName} on table {tableName}, unable to model the end of the foreign key on principal table {principaltableName}. This is usually because the principal table was not included in the selection set.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string LogPrincipalTableNotInSelectionSet {
            get {
                return ResourceManager.GetString("LogPrincipalTableNotInSelectionSet", resourceCulture);
            }
        }
        
        /// <summary>
        ///   The properties {properties} are configured to use &apos;Identity&apos; value generator and are mapped to the same table &apos;{table}&apos;. Only one column per table can be configured as &apos;Identity&apos;. Call &apos;ValueGeneratedNever&apos; for properties that should not use &apos;Identity&apos;.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string MultipleIdentityColumns {
            get {
                return ResourceManager.GetString("MultipleIdentityColumns", resourceCulture);
            }
        }
        
        /// <summary>
        ///   The database name could not be determined. To use EnsureDeleted, the connection string must specify Initial Catalog.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string NoInitialCatalog {
            get {
                return ResourceManager.GetString("NoInitialCatalog", resourceCulture);
            }
        }
        
        /// <summary>
        ///   The property &apos;{property}&apos; on entity type &apos;{entityType}&apos; is configured to use &apos;SequenceHiLo&apos; value generator, which is only intended for keys. If this was intentional configure an alternate key on the property, otherwise call &apos;ValueGeneratedNever&apos; or configure store generation for this property.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string NonKeyValueGeneration {
            get {
                return ResourceManager.GetString("NonKeyValueGeneration", resourceCulture);
            }
        }
        
        /// <summary>
        ///   SQL Server sequences cannot be used to generate values for the property &apos;{property}&apos; on entity type &apos;{entityType}&apos; because the property type is &apos;{propertyType}&apos;. Sequences can only be used with integer properties.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string SequenceBadType {
            get {
                return ResourceManager.GetString("SequenceBadType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   An exception has been raised that is likely due to a transient failure. Consider enabling transient error resiliency by adding &apos;EnableRetryOnFailure()&apos; to the &apos;UseSqlServer&apos; call.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string TransientExceptionDetected {
            get {
                return ResourceManager.GetString("TransientExceptionDetected", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Data type &apos;{dataType}&apos; is not supported in this form. Either specify the length explicitly in the type name, for example as &apos;{dataType}(16)&apos;, or remove the data type and use APIs such as HasMaxLength to allow EF choose the data type.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string UnqualifiedDataType {
            get {
                return ResourceManager.GetString("UnqualifiedDataType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Data type &apos;{dataType}&apos; for property &apos;{property}&apos; is not supported in this form. Either specify the length explicitly in the type name, for example as &apos;{dataType}(16)&apos;, or remove the data type and use APIs such as HasMaxLength to allow EF choose the data type.과(와) 유사한 지역화된 문자열을 찾습니다.
        /// </summary>
        public static string UnqualifiedDataTypeOnProperty {
            get {
                return ResourceManager.GetString("UnqualifiedDataTypeOnProperty", resourceCulture);
            }
        }
    }
}
